@app.on_message(filters.command("skorssk"))
async def ratingsa(c:Client, m:Message):
    if message.chat.type == "private":
        return await message.reply(f"{nogroup}")

    metin = """**ğŸ–ï¸  Global Top 20  ğŸ–ï¸**

"""
    eklenen = 1
    s = sorted(rating.items(), key=lambda x: x[1], reverse=True)
    for kisi in s:
        if eklenen == 1:
            metin +=  f"ğŸ¥‡  **{kisi[0]}  :  {kisi[1]}  Puan**\n" 
        if eklenen == 2:
            metin +=  f"ğŸ¥ˆ  **{kisi[0]}  :  {kisi[1]}  Puan**\n"
        if eklenen == 3:
            metin +=  f"ğŸ¥‰  **{kisi[0]}  :  {kisi[1]}  Puan**\n"
        if  not eklenen in [1,2,3]:
            metin +=  f" **{eklenen})  {kisi[0]}**  :  **{kisi[1]}  Puan**\n" 
        eklenen+=1
        if eklenen == 21:
            break
    await c.send_message(m.chat.id, metin)


import os
import re
from datetime import datetime, timedelta
import asyncio

import lyricsgenius as lg
from bs4 import BeautifulSoup

GENIUS_API_TOKEN = "VpT8NFnj4pTAYgaqAQj4eCIBCJk5ajA_F_PkFH-hH38Q8XhcEwT2Ro-NMWZ7vtfd"

class Lyric:
    def __init__(self, lyric, artist, title, image_url, url):
        self.lyric = lyric
        self.artist = artist
        self.title = title
        self.image_url = image_url
        self.url = url

async def get_lyrics(title: str):
    geniusClient = lg.Genius(
        GENIUS_API_TOKEN,
        skip_non_songs=True,
        verbose=False,
        excluded_terms=["(Remix)", "(Live)"],
        remove_section_headers=True,
    )

    def handler(lyrics: str):
        def remove_embed(lyrics: str):
            lyrics = re.sub(r"\d*Embed", "", lyrics)
            return lyrics

        def remove_first_line(lyrics: str):
            return "\n".join(lyrics.split("\n")[1:])

        return remove_first_line(remove_embed(lyrics))

    try:
        S = geniusClient.search_song(title, get_full_info=False)
        lyric = handler(S.lyrics)
        artist = S.artist
        title = S.title
        image_url = S.song_art_image_url
        url = S.url
        return Lyric(lyric, artist, title, image_url, url)
    except:
        return None

@app.on_message(filters.command(["lyrics"]))
async def lyrics(client: Client, message: Message):
    if len(message.command) < 2:
        await message.reply_text(
            f"KullanÄ±m:\n/{message.command[0]} <ÅŸarkÄ± adÄ±>"
        )
        return

    song_name = message.text.split(None, 1)[1]

    msg = await message.reply_text("ğŸ” ÅarkÄ± sÃ¶zleri aranÄ±yor...")

    lyric = await get_lyrics(song_name)
    if lyric is None:
        await msg.edit(f"ÅarkÄ± sÃ¶zleri bulunamadÄ±: {song_name}")
        return

    title = lyric.title
    artist = lyric.artist
    lyrics = lyric.lyric
    url = lyric.url
    image_url = lyric.image_url

    text = f"<b>ğŸˆ ÅarkÄ± : {title}</b>\n\n"
    text += f"<b>ğŸ‚ SanatÃ§Ä± : {artist}</b>\n\n"
    text += f"{lyrics}\n\n"

    if len(text) > 4096:
        text = text[:4050] + f"devamÄ±nÄ± oku ... {url}"
        await msg.edit(text, disable_web_page_preview=True)
        return
    else:
        text += f"<b>ğŸŒ¹ Kaynak : {url}</b>"
        await msg.edit(text, disable_web_page_preview=True)
        return


@client.on(events.NewMessage(pattern='^/stats ?(.*)'))
async def son_durum(event):
    # Bot Stats 
    if str(event.sender_id) not in SUDO_USERS:
        return await event.reply("**Sen sudo deÄŸilsin. Botun Statiklerini Ã–ÄŸrenemezsin!")
    global anlik_calisan,grup_sayi,ozel_list
    sender = await event.get_sender()
    if sender.id not in ozel_list:
      return
    await event.respond(f"**{bot_username} Ä°statistikleri ğŸ¤–**\n\nToplam Grup: `{len(grup_sayi)}`\nAnlÄ±k Ã‡alÄ±ÅŸan Grup: `{len(anlik_calisan)}`")


@client.on(events.NewMessage(pattern="^/reload$"))
async def reload_vps(event):
    try:
        # MesajÄ± gÃ¶nder
        reload_message = await event.respond("VPS Yenileniyor... â³ Bu birkaÃ§ saniye sÃ¼rebilir.")

        # 10 saniye bekleyin
        await asyncio.sleep(10)

        # MesajÄ± gÃ¼ncelle
        await reload_message.edit("VPS Yenilendi! âœ…")
    except Exception as e:
        # Hata durumunda mesaj gÃ¶nder
        await event.respond(f"Hata oluÅŸtu: {str(e)}")


@client.on(events.NewMessage(pattern="^/sozluk (.+)$"))
async def sozluk_command(event):
    try:
        # Komuttan kelimeyi al
        query_word = event.pattern_match.group(1)

        # API'ye isteÄŸi gÃ¶nder
        api_url = "https://api.collectapi.com/dictionary/wordSearchTurkish"
        headers = {
            'content-type': 'application/json',
            'authorization': 'apikey 4vummoAcfHEEdB2quMSNKK:3xpnojA2cyhcuZ8MM7LG6C'
        }
        params = {
            'query': query_word
        }

        response = requests.get(api_url, headers=headers, params=params)

        if response.status_code == 200:
            dictionary_data = response.json()
            if dictionary_data.get("success", False):
                word_info_list = dictionary_data.get("result", [])
                
                # Sadece ilk anlamÄ± al
                first_word_info = word_info_list[0] if word_info_list else {}

                madde = first_word_info.get('madde', {})
                kelime_sayi = madde.get('kelime_sayÄ±', 'Bilgi Yok')
                kelime_list = madde.get('kelime', [])

                message = f"ğŸ“– SÃ¶zlÃ¼k AnlamÄ± ({query_word}):\n\n"

                for kelime in kelime_list:
                    anlam = kelime.get('anlam', 'Bilgi Yok')
                    ornek_list = kelime.get('ornek', [])
                    ozellik_list = kelime.get('ozellik', [])

                    for ornek in ornek_list:
                        ornek_metni = ornek.get('ornek', 'Bilgi Yok')
                        yazar = ornek.get('yazar', 'Bilgi Yok')

                        ornek_message = (
                            f"ğŸ”¸ Anlam: {anlam}\n"
                            f"ğŸ”¸ Ã–rnek: {ornek_metni}\n"
                        )

                        message += ornek_message

                    for ozellik in ozellik_list:
                        tam_adi = ozellik.get('tamAdÄ±', 'Bilgi Yok')
                        kisa_adi = ozellik.get('kÄ±saAdÄ±', 'Bilgi Yok')

                        ozellik_message = (
                            f"ğŸ”¸ Ã–zellik: {tam_adi} ({kisa_adi})\n"
                        )

                        message += ozellik_message

                    message += "\n"

                # MesajÄ± gÃ¶nder
                await event.respond(message)
            else:
                await event.respond("SÃ¶zlÃ¼k anlamÄ± bulunamadÄ±.")
        else:
            await event.respond(f"Hata oluÅŸtu. HTTP Status Code: {response.status_code}")

    except Exception as e:
        # Hata durumunda mesaj gÃ¶nder
        await event.respond(f"Hata oluÅŸtu: {str(e)}")



bot_token = '6404904263:AAHP25SjaF85qCncHTq5NE9zA4A-ASD5XNA'

bot_active = False

bot = telebot.TeleBot(bot_token)

# /yas komutuna yanÄ±t veren bir iÅŸlev
@bot.message_handler(commands=['yas'])
def calculate_age(message):
    try:
        # Komutu kullanan kullanÄ±cÄ±nÄ±n doÄŸum tarihini alÄ±n
        birthday_str = message.text.split()[-1]
        birthday = datetime.strptime(birthday_str, "%d.%m.%Y")

        # Åu anki tarihi alÄ±n
        current_date = datetime.now()

        # KullanÄ±cÄ±nÄ±n yaÅŸÄ±nÄ± hesaplayÄ±n
        age = current_date.year - birthday.year - ((current_date.month, current_date.day) < (birthday.month, birthday.day))

        # DoÄŸum gÃ¼nÃ¼nÃ¼n ne kadar zaman sonra olduÄŸunu hesaplayÄ±n
        next_birthday = datetime(current_date.year, birthday.month, birthday.day)
        if current_date > next_birthday:
            next_birthday = datetime(current_date.year + 1, birthday.month, birthday.day)
        days_until_birthday = (next_birthday - current_date).days

        # KullanÄ±cÄ±ya cevap verin
        reply_message = f"ğŸ‰ sá´‡á´ É¢ÉªÊŸÉª {message.from_user.first_name}\n"
        reply_message += f"ğŸ’­ sÌ§á´œá´€É´á´…á´€ {age} Êá´€sÌ§ÉªÉ´á´…á´€sÉªÉ´ .\n\n"
        reply_message += f"ğŸ‚ á´…á´É¢Ì†á´œá´ É¢á´œÌˆÉ´á´œÌˆÉ´ {days_until_birthday} É¢á´œÌˆÉ´ sá´É´Ê€á´€ ."
        bot.reply_to(message, reply_message)
    except ValueError:
        bot.reply_to(message, "ğŸ—’ï¸ É¢á´‡á´„Ì§á´‡Ê€sÉªá´¢ á´›á´€Ê€ÉªÊœ .\ná´…á´É¢Ì†Ê€á´œ Ê™ÉªÊ€ á´›á´€Ê€ÉªÊœ É¢ÉªÊ€ÉªÉ´ .\ná´ÌˆÊ€É´á´‡á´‹ : 30.01.2000")
    except Exception as e:
        bot.reply_to(message, "ğŸ—’ï¸ Ê™ÉªÊ€ Êœá´€á´›á´€ á´ÊŸá´œsÌ§á´›á´œ .\nsá´É´Ê€á´€ á´›á´‡á´‹Ê€á´€Ê€ á´…á´‡É´á´‡ÊÉªÉ´ .")

# /burc komutuna yanÄ±t veren bir iÅŸlev
@bot.message_handler(commands=['burc'])
def calculate_zodiac_sign(message):
    try:
        # Komutu kullanan kullanÄ±cÄ±nÄ±n doÄŸum tarihini alÄ±n
        birthday_str = message.text.split()[-1]
        birthday = datetime.strptime(birthday_str, "%d.%m.%Y")

        # BurÃ§larÄ± ve tarih aralÄ±klarÄ±nÄ± tanÄ±mlayÄ±n
        zodiac_signs = [
            {"name": "ğ—„ğ—ˆğ–¼Ì§", "start_date": datetime(birthday.year, 3, 21), "end_date": datetime(birthday.year, 4, 19)},
            {"name": "ğ–»ğ—ˆğ—€Ì†ğ–º", "start_date": datetime(birthday.year, 4, 20), "end_date": datetime(birthday.year, 5, 20)},
            {"name": "ğ—‚ğ—„ğ—‚ğ—“ğ—…ğ–¾ğ—‹", "start_date": datetime(birthday.year, 5, 21), "end_date": datetime(birthday.year, 6, 20)},
            {"name": "ğ—’ğ–¾ğ—‡ğ—€ğ–¾ğ–¼Ì§", "start_date": datetime(birthday.year, 6, 21), "end_date": datetime(birthday.year, 7, 22)},
            {"name": "ğ–ºğ—Œğ—…ğ–ºğ—‡", "start_date": datetime(birthday.year, 7, 23), "end_date": datetime(birthday.year, 8, 22)},
            {"name": "ğ–»ğ–ºğ—ŒÌ§ğ–ºğ—„", "start_date": datetime(birthday.year, 8, 23), "end_date": datetime(birthday.year, 9, 22)},
            {"name": "ğ—ğ–¾ğ—‹ğ–ºğ—“ğ—‚", "start_date": datetime(birthday.year, 9, 23), "end_date": datetime(birthday.year, 10, 22)},
            {"name": "ğ–ºğ—„ğ—‹ğ–¾ğ—‰", "start_date": datetime(birthday.year, 10, 23), "end_date": datetime(birthday.year, 11, 21)},
            {"name": "ğ—’ğ–ºğ—’", "start_date": datetime(birthday.year, 11, 22), "end_date": datetime(birthday.year, 12, 21)},
            {"name": "ğ—ˆğ—€Ì†ğ—…ğ–ºğ—„", "start_date": datetime(birthday.year, 12, 22), "end_date": datetime(birthday.year, 1, 19)},
            {"name": "ğ—„ğ—ˆğ—ğ–º", "start_date": datetime(birthday.year, 1, 20), "end_date": datetime(birthday.year, 2, 18)},
            {"name": "ğ–»ğ–ºğ—…Ä±ğ—„", "start_date": datetime(birthday.year, 2, 19), "end_date": datetime(birthday.year, 3, 20)},
        ]

        # KullanÄ±cÄ±nÄ±n burcunu bulun
        zodiac_sign = None
        for sign in zodiac_signs:
            if sign["start_date"] <= birthday <= sign["end_date"]:
                zodiac_sign = sign["name"]
                break

        if zodiac_sign:
            bot.reply_to(message, f"ğŸ’­ {birthday_str} á´›á´€Ê€ÉªÊœÉªÉ´á´…á´‡ \nğŸŒŸ á´…á´É¢Ì†á´…á´œÉ¢Ì†á´œÉ´á´œá´¢á´€ É¢á´ÌˆÊ€á´‡ ...\n\nâœ“ Ê™á´œÊ€á´„á´œÉ´á´œá´¢ : {zodiac_sign}")
        else:
            bot.reply_to(message, "ğŸ—’ï¸ É¢á´‡á´„Ì§á´‡Ê€sÉªá´¢ á´›á´€Ê€ÉªÊœ á´ á´‡Êá´€ Ê™á´œÊ€á´„Ì§ Êœá´‡sá´€á´˜ÊŸá´€É´á´€á´á´€á´…Éª ...")
    except ValueError:
        bot.reply_to(message, "ğŸ—’ï¸ É¢á´‡á´„Ì§á´‡Ê€sÉªá´¢ á´›á´€Ê€ÉªÊœ .\ná´…á´É¢Ì†Ê€á´œ Ê™ÉªÊ€ á´›á´€Ê€ÉªÊœ É¢ÉªÊ€ÉªÉ´ .\ná´ÌˆÊ€É´á´‡á´‹ : 30.01.2000")
    except Exception as e:
        bot.reply_to(message, "ğŸ—’ï¸ Ê™ÉªÊ€ Êœá´€á´›á´€ á´ÊŸá´œsÌ§á´›á´œ .\nsá´É´Ê€á´€ á´›á´‡á´‹Ê€á´€Ê€ á´…á´‡É´á´‡ÊÉªÉ´ .")

# SUS KOMUTUNA YANIT VEREN BÄ°R Ä°ÅLEV
@bot.message_handler(commands=['susjdkrkr'])
def deactivate_bot(message):
    global bot_active
    bot_active = False
    bot.reply_to(message, "Bot ÅŸu an pasif.")

# KONUS KOMUTUNA YANIT VEREN BÄ°R Ä°ÅLEV
@bot.message_handler(commands=['konuskdjdk'])
def activate_bot(message):
    global bot_active
    bot_active = True
    bot.reply_to(message, "Bot ÅŸu an aktif.")

# Ä°P KOMUTUNA YANIT VEREN BÄ°R Ä°ÅLEV
@bot.message_handler(commands=['ipdndjr'])
def ip_sorgu(message):
    try:
        ip = message.text.split()[-1]

        # IP sorgusu iÅŸlemi
        response = requests.get(f"http://ip-api.com/json/{ip}").json()

        if response["status"] == "success":
            # IP sorgusu baÅŸarÄ±lÄ± ise sonucu Ã¶zelleÅŸtirin
            result = "ğŸŒ IP Bilgileri ğŸŒ\n\n"
            result += f"ğŸ”¹ **IP Adresi:** `{response['query']}`\n"
            result += f"ğŸ”¹ **Ãœlke:** `{response['country']}`\n"
            result += f"ğŸ”¹ **Åehir:** `{response['city']}`\n"
            result += f"ğŸ”¹ **Posta Kodu:** `{response['zip']}`\n"
            result += f"ğŸ”¹ **Koordinatlar:** `{response['lat']}, {response['lon']}`\n"

            bot.reply_to(message, result)
        else:
            bot.reply_to(message, "IP sorgusu baÅŸarÄ±sÄ±z oldu.")
    except IndexError:
        bot.reply_to(message, "âŒ Ä°ÅŸlem BaÅŸarÄ±sÄ±z\nâ—ï¸ LÃ¼tfen GeÃ§erli Bir IP Adresi Giriniz!\n\nÃ–rnek: /ip 8.8.8.8")
    except Exception as e:
        bot.reply_to(message, "âŒ Bir Hata OluÅŸtu\n\nLÃ¼tfen Daha Sonra Tekrar Deneyin. . .â³")

# DNS KOMUTUNU Ä°ÅLEYÄ°N
@bot.message_handler(commands=['dnsjsdjkd'])
def dns_sorgu(message):
    try:
        domain = message.text.split()[-1]

        # DNS sorgusu iÅŸlemi
        response = requests.get(f"http://ip-api.com/json/{domain}").json()

        if response["status"] == "success":
            # DNS sorgusu baÅŸarÄ±lÄ± ise sonucu Ã¶zelleÅŸtirin
            result = "ğŸŒ DNS Sorgusu ğŸŒ\n\n"
            result += f"ğŸ”¹ **Domain AdÄ±:** `{domain}`\n"
            result += f"ğŸ”¹ **IP Adresi:** `{response['query']}`\n"

            bot.reply_to(message, result, parse_mode='Markdown')
        else:
            bot.reply_to(message, "âŒ DNS sorgusu baÅŸarÄ±sÄ±z oldu veya bu domain iÃ§in herhangi bir IP adresi bulunamadÄ±.")
    except IndexError:
        bot.reply_to(message, "âŒ Ä°ÅŸlem BaÅŸarÄ±sÄ±z\nâ—ï¸ LÃ¼tfen GeÃ§erli Bir Domain AdÄ± Giriniz!\n\nÃ–rnek: /dns example.com")
    except Exception as e:
        bot.reply_to(message, f"âŒ Bir Hata OluÅŸtu\n\nHata DetayÄ±: {str(e)}")

# Bot'u Ã§alÄ±ÅŸtÄ±rÄ±n
while True:
    try:
        bot.polling(none_stop=True)
    except Exception as e:
        pass
